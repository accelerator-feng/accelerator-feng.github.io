<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>和光同尘</title>
  <subtitle>前端小白的学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yinfengblog.com/"/>
  <updated>2017-05-11T13:24:15.000Z</updated>
  <id>http://www.yinfengblog.com/</id>
  
  <author>
    <name>Yin Feng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shouldComponentUpdate及diff算法原理（转载）</title>
    <link href="http://www.yinfengblog.com/shouldComponentUpdate%E5%8F%8Adiff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>http://www.yinfengblog.com/shouldComponentUpdate及diff算法原理（转载）/</id>
    <published>2017-04-19T12:22:08.000Z</published>
    <updated>2017-05-11T13:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>React官方文档中关于shouldComponentUpdate和diff算法的部分（翻译）<br><a id="more"></a> </p>
<blockquote>
<p>原文链接：<a href="https://my.oschina.net/chkui/blog/874483" target="_blank" rel="external">https://my.oschina.net/chkui/blog/874483</a></p>
</blockquote>
<h2 id="shouldComponentUpdate原理"><a href="#shouldComponentUpdate原理" class="headerlink" title="shouldComponentUpdate原理"></a>shouldComponentUpdate原理</h2><p>React构建和维护了一个内部的虚拟Dom，这个Dom和真实的UI是相互映射的关系，他包含从用户自定义组件中返回的各种React元素。这个虚拟的Dom使得React可以避免重复渲染相同的Dom节点并在访问存在的节点时直接使用React的虚拟层数据，这样设计的原因是重复渲染浏览器或web view的UI比操作一个JavaScript的对象要慢许多。在React Native也采用同样的处理方式。</p>
<p>当组件的props和state变更时，React会将最新返回的元素与之前旧的元素进行对比来确定是否真的需要重新渲染真实的Dom。当他们不相等时，React会更新真实的Dom。</p>
<p>在某些情况下，可以在自定义组件中重载<code>shouldComponentUpdate</code>方法来加速触发渲染的比对的过程。该方法的默认实现返回参数为true，此时React将按照原来的方式进行比对和渲染：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在某些情况下能够清晰的明确组件不需要重新渲染，可以在<code>shouldComponentUpdate</code>方法中返回<code>false</code>，这样会让让组件跳过整个渲染过程，包括不再调用当前组件和子组件的render()方法。</p>
<h3 id="shouldComponentUpdate-的执行过程"><a href="#shouldComponentUpdate-的执行过程" class="headerlink" title="shouldComponentUpdate 的执行过程"></a>shouldComponentUpdate 的执行过程</h3><p>下面是一个组件结构树。图中，“SCU”表示<code>shouldComponentUpdate</code>方法返回的值（绿色true，红色fasle），“vDOMEq”表示React的匹配是否一致（绿色true，红色fasle），有颜色的红圈表示是否执行了UI重绘（绿色表示没重绘，红色表示执行重绘）。</p>
<p><img src="http://i4.buimg.com/582196/6b65e9dd428d2450.png" style="
    margin: 0 auto;
    display: block;
"></p>
<p>在C2组件中，<code>houldComponentUpdate</code>方法返回了false，所以React不会判断是否需要重新渲染C2并且不执行render()方法，&nbsp;因此在C4和C5中不再执行<code>shouldComponentUpdate</code>方法。</p>
<p>对于C1和C3，<code>shouldComponentUpdate</code>都返回了true，所以React必须对着2个组件进行比对。对于C6，<code>shouldComponentUpdate</code>返回true，而且比对的结果是需要UI重绘，因此C6会更新他们的真实Dom。</p>
<p>还有一个值得关心的组件是C8，React在这个组件中执行了render()方法，但是由于虚拟Dom并没有发生变更，前后比对一致，所以并没有发生真实Dom渲染。</p>
<p>在整个过程中React仅仅变更了C6组件的UI样式，C8由于前后虚拟Dom一致因此没有真正的执行UI渲染。C2、C2的子组件以及C7没有执行render()方法。</p>
<h3 id="一个shouldComponentUpdate的例子"><a href="#一个shouldComponentUpdate的例子" class="headerlink" title="一个shouldComponentUpdate的例子"></a>一个shouldComponentUpdate的例子</h3><p>在例子中，当props.color和state.count发生变更时进行UI渲染，我们在<code>shouldComponentUpdate</code>方法中进行检查：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">    <span class="comment">//只判断props.color和nextState.count是否变更，其他情况均不渲染</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.color !== nextProps.color) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.count !== nextState.count) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;button</div><div class="line">        color=&#123;this.props.color&#125;</div><div class="line">        onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt;</div><div class="line">        Count: &#123;this.state.count&#125;</div><div class="line">      &lt;/button&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这段代码中，<code>shouldComponentUpdate</code>仅仅检查<code>props.color</code>和<code>state.count</code>是否发生变更，如果他们的值没有修改，组件将不会发生任何更新。在实际使用中，组件往往比这个复杂，我们可以使用类似于“浅比较”（关于浅比较可以参看：<a href="https://facebook.github.io/react/docs/shallow-compare.html" rel="external" target="_blank">Shallow Compare</a>）的模式来比对所有的属性或状态是否发生变更。React提供了这个模式的一个实现组件，只要让组件继承自<code>React.PureComponent</code>即可。我们可以将代码进行下面的修改：                                          </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//继承自React.PureComponent</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;button</div><div class="line">        color=&#123;this.props.color&#125;</div><div class="line">        onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt;</div><div class="line">        Count: &#123;this.state.count&#125;</div><div class="line">      &lt;/button&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在大部分情况下，只要使用<code>React.PureComponent</code>就可以代替我们自己重载<code>shouldComponentUpdate</code>方法，但是它仅仅适用于“浅比较”，所以这个组件不适用于props和state数据发生突变的情况。</p>
<p><em>附：数据突变（mutated）是指变量的引用没有改变（指针地址未改变），但是引用指向的数据发生了变化（指针指向的数据发生变更）。例如<code>const x = {foo:&#39;foo&#39;}</code>。<code>x.foo=&#39;none&#39;</code>就是一个突变。</em></p>
<p>在更复杂的数据结构中还会存在一些问题。例如下面的代码，我们希望<code>ListOfWords</code>组件将words参数渲染成一个逗号分隔的字符串，而父组件监控点击事件，每次点击都会增加一个单词到列表中，但是下面的代码并不会正确工作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListOfWords</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;this.props.words.join(',')&#125;&lt;/div&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordAdder</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">words</span>: [<span class="string">'marklar'</span>]</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  handleClick() &#123;</div><div class="line">    <span class="comment">// 这段内容会导致代码不按照预期工作。</span></div><div class="line">    <span class="keyword">const</span> words = <span class="keyword">this</span>.state.words;</div><div class="line">    words.push(<span class="string">'marklar'</span>);</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">words</span>: words&#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;button onClick=&#123;this.handleClick&#125; /&gt;</div><div class="line">        &lt;ListOfWords words=&#123;this.state.words&#125; /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>导致代码无法正常工作的原因是<code>PureComponent</code>仅仅对 this.props.words的新旧值进行“浅比较”。在words值在<code>handleClick</code>中被修改之后，即使有新的单词被添加到数组中，但是this.props.words的新旧值在进行比较时是一样的（引用对象比较），因此<code>ListOfWords</code>一直不会发生渲染。</p>
<h3 id="非突变数据的价值"><a href="#非突变数据的价值" class="headerlink" title="非突变数据的价值"></a>非突变数据的价值</h3><p>有一个简单的方法预防上面提到的问题，就是在使用prop和state时防止数据发生突变。例如下面的例如，我们用数组的concat方法来代替等号“=”，这样在concat后会产生一个新的数组赋值给this.state.words：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">handleClick() &#123;</div><div class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">words</span>: prevState.words.concat([<span class="string">'marklar'</span>])</div><div class="line">  &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6支持列表扩展语法，因此我们更容易在es6中实现非突变的数据赋值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">handleClick() &#123;</div><div class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">words</span>: [...prevState.words, <span class="string">'marklar'</span>],</div><div class="line">  &#125;));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以重写传统的赋值语句防止对象中的数据发生数据突变。下面的例子有一个名为<code>colormap</code>的对象，我们想在修改<code>colormap.right</code>的值时渲染组件，我们可以这样重写组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateColorMap</span>(<span class="params">colormap</span>) </span>&#123;</div><div class="line">  colormap.right = <span class="string">'blue'</span>; <span class="comment">//浅拷贝，指针地址未变，数据发生变化。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以使用&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="external" target="_blank">Object.assign</a>&nbsp;方法来防止数据突变：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateColorMap</span>(<span class="params">colormap</span>) </span>&#123;</div><div class="line">  <span class="comment">// 深拷贝，修改返回对象的地址</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, colormap, &#123;<span class="attr">right</span>: <span class="string">'blue'</span>&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改后<code>updateColorMap</code>方法返回一个新的实例。需要注意的是某些浏览器不支持<code>Object.assign</code>方法，我们需要使用polyfill（差异化抹平，比如我们引入了babel-polyfill）来解决这个问题。<br>有一个新的JavaScript方案是使用 扩展传播特性（见 <a href="https://github.com/sebmarkbage/ecmascript-rest-spread" rel="external" target="_blank">object spread properties</a>）来解决数据突变问题，实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateColorMap</span>(<span class="params">colormap</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;...colormap, <span class="attr">right</span>: <span class="string">'blue'</span>&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是构建React的App应用，那么以上方法都能够很好的支持，如果是在浏览器环境使用，需要引入polyfill机制。</p>
<h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>React提供了一系列声明性的API接口，因此在使用时不必担心每次库的更新会修改API接口。这样可以降低编写应用的复杂度，但是带来的问题是无法很好的理解React是如何实现这些功能的。这篇文章会介绍React的差异比对算法——“融合算法”是如何执行的。</p>
<h3 id="差异匹配算法实现的前提"><a href="#差异匹配算法实现的前提" class="headerlink" title="差异匹配算法实现的前提"></a>差异匹配算法实现的前提</h3><p>我们先来看看第一个值得关注的我问题： render() 方法的作用是创建React元素的树形结构，当state或props发生更新后， render() 会返回一个与之前有差异的结构树。在这个机制下，React需要弄清楚如何匹配最近的树并有效的更新UI。</p>
<p>针对以上问题，有一些通用的算法可供参考，比如比对2颗树的差异，在前一个颗树的基础上生成最小操作树，但是这个算法的时间复杂度为n的三次方=O(n<em>n</em>n)，当树的节点较多时，这个算法的时间代价会导致算法几乎无法工作。</p>
<p>架设在我们使用React时，一共部署了1000个元素，那么使用上面的算法，我们要比对数亿次才能得到比对的结果，根本不可能在一个浏览器中短时间完成。React实现了一个计算复杂度是O(n)的算法来解决这个问题，这个算法基于2个假设：</p>
<p>不同类型的2个元素产生不同的树。<br>开发人员可以为不同的子节点在渲染之前设定一个“key”属性值。<br>实际上，这个假设对于几乎所有的实际用例都是有效的。</p>
<h3 id="差异算法"><a href="#差异算法" class="headerlink" title="差异算法"></a>差异算法</h3><p>对于2颗有差异的树，React首先比对2颗树的根节点。根据跟节点的类型是否相同，算法接下来会执行不同的操作。</p>
<h4 id="Types不一样"><a href="#Types不一样" class="headerlink" title="Types不一样"></a>Types不一样</h4><p>一旦2棵树之间的根元素类型不一样，React会直接移除旧的树并构建出新的树。例如从 <code>&lt;a&gt;</code> 变更为 <code>&lt;img&gt;</code>、 <code>&lt;Article&gt;</code> 变更为 <code>&lt;Comment&gt;</code>、 <code>&lt;Button&gt;</code> 变更为 <code>&lt;div&gt;</code> ，所有的这些变化都会导致整颗树重构。</p>
<p>重构一棵新的树时，所有的旧节点都会移除。组件的componentWillUnmount()方法会被调用。 然后到构建完成之后新的Dom会替换原来的Dom。此时组件的componentWillMount()和componentDidMount()会依次被调用。旧树Dom上的所有状态都会丢失。</p>
<p>根据这个特性，根节点之后的所有组件都会卸载并重建，状态也会随之改变。例如下面2个组件对比：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p> Counter 组件会被销毁并重新安装一个新的组件。</p>
<h4 id="Dom元素拥有相同的类型"><a href="#Dom元素拥有相同的类型" class="headerlink" title="Dom元素拥有相同的类型"></a>Dom元素拥有相同的类型</h4><p>当比较React元素为相同类型时，React会查看元素上的属性来比对。比对之后，React会保持的Dom节点不改变然后仅仅更新不同的属性值，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"before"</span> <span class="attr">title</span>=<span class="string">"stuff"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"after"</span> <span class="attr">title</span>=<span class="string">"stuff"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>在比对这2个元素之后，React知道仅仅需要修改当前Dom的className。在更新style时，React同样知道仅仅需要更新修改部分即可。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> '<span class="attr">red</span>', <span class="attr">fontWeight:</span> '<span class="attr">bold</span>'&#125;&#125; /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> '<span class="attr">green</span>', <span class="attr">fontWeight:</span> '<span class="attr">bold</span>'&#125;&#125; /&gt;</span></div></pre></td></tr></table></figure>
<p>在转换这2个组件时，React知道仅仅需要修改color的样式，而fontWeight不必发生变动。</p>
<p>在处理完当前Dom节点后，React依次对子节点进行递归。</p>
<h4 id="组件元素拥有相同的类型"><a href="#组件元素拥有相同的类型" class="headerlink" title="组件元素拥有相同的类型"></a>组件元素拥有相同的类型</h4><p>当一个组件发生更新后，实例依然是原来的实例，所以状态还是以前的状态。React通过属性值（props）的更新来影响需要更新组件，此时组件实例的 componentWillReceiveProps() 和 componentWillUpdate() 方法会被调用。</p>
<p>然后， render() 方法会被调用并返回一个Dom，差异算法会递归比对之前返回Dom的差异。</p>
<h4 id="递归子元素"><a href="#递归子元素" class="headerlink" title="递归子元素"></a>递归子元素</h4><p>默认情况下，在递归子元素的Dom节点时，React同时对2个子元素列表进行迭代比对，如果发现差异都会产生一个突变。</p>
<p>例如，当增加一个元素在子元素的队尾，这2颗树的转换效率很高：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>third<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>React先匹配 <code>&lt;li&gt;first&lt;/li&gt;</code> 2棵树，然后再匹配 <code>&lt;li&gt;second&lt;/li&gt;</code> 。最后直接就添加 <code>&lt;li&gt;third&lt;/li&gt;</code> 节点。</p>
<p>如果代码按下面的方式修改2颗树，执行的效率相对较差：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Connecticut<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>React会突变修改所有的子节点，最终 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和 <code>&lt;li&gt;Villanova&lt;/li&gt;</code> 会被重新渲染。所以这种方式会带来很大的效率问题。</p>
<h4 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h4><p>为了解决上面的问题，React提供了一个“key”属性。当所有的子元素都有一个key值，React直接使用key值来比对树形结构中的所有子节点列表。例如为上面的的例子增加一个key会大大的提升转换效率：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2015"</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2016"</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2014"</span>&gt;</span>Connecticut<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2015"</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2016"</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>现在React可以知道key=’2014’的节点是一个新值另外2个节点仅仅需要移动一下位置。</p>
<p>在实际使用中，key值并不难找。在常规业务中，很多列表都自然包含业务相关的ID了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当无法使用业务ID时，也可以额外增加一个ID值来标记列表差异，比如根据要使用的数据生成一个hash值，React不需要key值全局唯一，只需要在兄弟节点之间保持唯一即可。</p>
<p>最差情况下，你可以使用索引数据（0、1、2、….n）。使用索引需要注意的是，如果列表发生重新排序效率会很糟糕。</p>
<h3 id="更多折中的考虑"><a href="#更多折中的考虑" class="headerlink" title="更多折中的考虑"></a>更多折中的考虑</h3><p>在使用React时需要谨记“一致性算法”是一个实现细则，他描述了React在各种情况下是如何工作的。在某些极端情况下，虽然最终呈现效果是一致的但是有可能每一个简单的操作都导致React全局重新渲染。本篇文章的目的就是启发普通用户在使用React开发时能获得更好的执行效率。</p>
<p>React在目前的实现中还存在一个问题，可以快捷的告知React子树中某个节点的位置已经发生改变，但是无法告知React他移动到了什么位置。因此在遇到这种情况时，算法会重构整个子树。</p>
<p>这是因为React依赖启发式算法，如果本文开篇提到的2个基本假设不成立，那么会导致算法效率极差。</p>
<p>1.算法不会尝试匹配不同2个组件之间的子树。如果编码中发现2个组件之间有非常相似的输出，应该尝试将2个组件合并为一个类型的组件。在实际应用中，我们还没发现这样导致问题。<br>2.用作列表的key值最好是稳定、可预见、唯一的。易变的key值（比如由Math.random()方法生成的值）将会导致许多组件实例和Dom节点被非必要的重新创建，这会导致性能低下且子组件丢失已有的状态。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React官方文档中关于shouldComponentUpdate和diff算法的部分（翻译）&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.yinfengblog.com/categories/JavaScript/"/>
    
    
      <category term="React" scheme="http://www.yinfengblog.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>学习前端模块化</title>
    <link href="http://www.yinfengblog.com/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://www.yinfengblog.com/学习前端模块化/</id>
    <published>2017-03-26T14:23:45.000Z</published>
    <updated>2017-05-10T12:02:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习CommonJS、AMD、ES6 Module以及UMD。<br><a id="more"></a> </p>
<h1 id="CommonJSm"><a href="#CommonJSm" class="headerlink" title="CommonJSm"></a>CommonJSm</h1><p>Node应用由模块组成，采用CommonJS模块规范。</p>
<p>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>
<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> value + x;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">module</span>.exports.x = x;</div><div class="line"><span class="built_in">module</span>.exports.addX = addX;</div></pre></td></tr></table></figure>
<p>上面代码通过module.exports输出变量x和函数addX。</p>
<p>require方法用于加载模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p>CommonJS模块特点:</p>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<p>CommonJS以服务器优先的方式来同步载入模块。</p>
<p>对于浏览器，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'myModule'</span>, <span class="string">'myOtherModule'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myModule, myOtherModule</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(myModule.hello());</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>第一个参数是一个数组，里面的成员就是要加载的模块；第二个参数是加载成功之后的回调函数。</p>
<h1 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h1><p>因为AMD，CommonJS规范是两种不一致的规范，虽然他们应用的场景也不太一致，但是人们仍然是期望有一种统一的规范来支持这两种规范。于是，UMD（Universal Module Definition，称之为 通用模块规范 ）规范诞生了。</p>
<p>客观来说，这个UMD规范看起来的确没有AMD和CommonJS规范简约。但是它支持AMD和CommonJS规范，同时还支持古老的全局模块模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</div><div class="line">      <span class="comment">// AMD</span></div><div class="line">    define([<span class="string">'myModule'</span>, <span class="string">'myOtherModule'</span>], factory);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</div><div class="line">      <span class="comment">// CommonJS</span></div><div class="line">    <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">'myModule'</span>), <span class="built_in">require</span>(<span class="string">'myOtherModule'</span>));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Browser globals (Note: root is window)</span></div><div class="line">    root.returnExports = factory(root.myModule, root.myOtherModule);</div><div class="line">  &#125;</div><div class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">myModule, myOtherModule</span>) </span>&#123;</div><div class="line">  <span class="comment">// Methods</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">notHelloOrGoodbye</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// A private method</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// A public method because it's returned (see below)</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">goodbye</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// A public method because it's returned (see below)</span></div><div class="line"></div><div class="line">  <span class="comment">// Exposed public methods</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">hello</span>: hello,</div><div class="line">      <span class="attr">goodbye</span>: goodbye</div><div class="line">  &#125;</div><div class="line">&#125;));</div></pre></td></tr></table></figure></p>
<h1 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h1><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习CommonJS、AMD、ES6 Module以及UMD。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.yinfengblog.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>FCC中级编程题整理</title>
    <link href="http://www.yinfengblog.com/FCC%E4%B8%AD%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://www.yinfengblog.com/FCC中级算法题整理/</id>
    <published>2017-03-16T05:33:21.000Z</published>
    <updated>2017-03-27T13:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.freecodecamp.cn/" target="_blank">freeCodeCamp</a>中级算法题整理解析。<br><a id="more"></a> </p>
<h2 id="Sum-All-Numbers-in-a-Range"><a href="#Sum-All-Numbers-in-a-Range" class="headerlink" title="Sum All Numbers in a Range"></a>Sum All Numbers in a Range</h2><p>我们会传递给你一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。</p>
<p>下面的方法使用 apply 方法寻找一个数值数组中的最大元素。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxOfArray</span>(<span class="params">numArray</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numArray);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者通过使用最新的扩展语句<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank">spread operator</a>，获得数组中的最大值变得更容易。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(...arr);</div></pre></td></tr></table></figure></p>
<p>本题答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumAll</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...arr),</div><div class="line">        min = <span class="built_in">Math</span>.min(...arr);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> sum = min; min &lt; max; min++) &#123; value += min + <span class="number">1</span>; &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Diff-Two-Arrays"><a href="#Diff-Two-Arrays" class="headerlink" title="Diff Two Arrays"></a>Diff Two Arrays</h2><p>比较两个数组，然后返回一个新数组，该数组的元素为两个给定数组中所有独有的数组元素。换言之，返回两个数组的差异。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">arr1, arr2</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> diff1 = arr1.filter(<span class="function"><span class="params">item</span> =&gt;</span> !arr2.includes(item)),</div><div class="line">        diff2 = arr2.filter(<span class="function"><span class="params">item</span> =&gt;</span> !arr1.includes(item));</div><div class="line">    <span class="keyword">return</span> diff1.concat(diff2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Roman-Numeral-Converter"><a href="#Roman-Numeral-Converter" class="headerlink" title="Roman Numeral Converter"></a>Roman Numeral Converter</h2><p>将给定的数字转换成罗马数字。<br>所有返回的 罗马数字 都应该是大写形式。</p>
<p>这题关键是弄清楚罗马数字的书写思路，根据”M”,”CM”等特殊值与阿拉伯数字的对应关系，总结出阿拉伯数字转换成罗马数字的转换方法，再使用JavaScript将自己总结的转换方法表达出来即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> decimalValue = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>],</div><div class="line">        romanNumeral = [<span class="string">'M'</span>, <span class="string">'CM'</span>, <span class="string">'D'</span>, <span class="string">'CD'</span>, <span class="string">'C'</span>, <span class="string">'XC'</span>, <span class="string">'L'</span>, <span class="string">'XL'</span>, <span class="string">'X'</span>, <span class="string">'IX'</span>, <span class="string">'V'</span>, <span class="string">'IV'</span>, <span class="string">'I'</span>],</div><div class="line">        len = decimalValue.length;</div><div class="line">    <span class="keyword">let</span> sum = <span class="string">""</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">while</span> (decimalValue[i] &lt;= num) &#123;</div><div class="line">            sum += romanNumeral[i];</div><div class="line">            num -= decimalValue[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Where-art-thou"><a href="#Where-art-thou" class="headerlink" title="Where art thou"></a>Where art thou</h2><p>写一个 function，它遍历一个对象数组（第一个参数）并返回一个包含相匹配的属性-值对（第二个参数）的所有对象的数组。如果返回的数组中包含 source 对象的属性-值对，那么此对象的每一个属性-值对都必须存在于 collection 的对象中。</p>
<p>例如，如果第一个参数是 <code>[{ first: &quot;Romeo&quot;, last: &quot;Montague&quot; }, { first: &quot;Mercutio&quot;, last: null }, { first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }]</code>，第二个参数是 <code>{ last: &quot;Capulet&quot; }</code>，那么你必须从数组（第一个参数）返回其中的第三个对象，因为它包含了作为第二个参数传递的属性-值对。</p>
<p>使用<code>filter()</code>方法，同时遍历source对象的属性-值对，将对象数组中不符合要求的对象剔除。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">where</span>(<span class="params">collection, source</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> collection.filter(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> pro <span class="keyword">in</span> source) &#123;</div><div class="line">            <span class="keyword">if</span> (!obj.hasOwnProperty(pro) || obj[pro] !== source[pro]) &#123;    <span class="comment">// 若对象没有指定属性，或属性不等于指定值</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Search-and-Replace"><a href="#Search-and-Replace" class="headerlink" title="Search and Replace"></a>Search and Replace</h2><p>使用给定的参数对句子执行一次查找和替换，然后返回新句子。</p>
<p>第一个参数是将要对其执行查找和替换的句子。</p>
<p>第二个参数是将被替换掉的单词（替换前的单词）。</p>
<p>第三个参数用于替换第二个参数（替换后的单词）。</p>
<p>注意：替换时保持原单词的大小写。例如，如果你想用单词 “dog” 替换单词 “Book” ，你应该替换成 “Dog”。</p>
<p>使用<code>replace()</code>方法替换<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myReplace</span>(<span class="params">str, before, after</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> index = str.indexOf(before);    <span class="comment">// 找到被替换单词位置</span></div><div class="line">    <span class="keyword">if</span> (str.charCodeAt(index) &lt; <span class="number">92</span>) &#123; after = after[<span class="number">0</span>].toUpperCase() + after.slice(<span class="number">1</span>); &#125;    <span class="comment">// 若被替换单词首字母大写</span></div><div class="line">    <span class="keyword">return</span> str.replace(before, after);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Pig-Latin"><a href="#Pig-Latin" class="headerlink" title="Pig Latin"></a>Pig Latin</h2><p>把指定的字符串翻译成 pig latin。</p>
<p>Pig Latin 把一个英文单词的第一个辅音或辅音丛（consonant cluster）移到词尾，然后加上后缀 “ay”。</p>
<p>如果单词以元音开始，你只需要在词尾添加 “way” 就可以了。</p>
<p>用正则匹配元音和辅音从<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (str.match(<span class="regexp">/^[aeiou]/</span>)) &#123;    <span class="comment">// 用/^[aeiou]/匹配在开头的元音字母     </span></div><div class="line">        <span class="keyword">return</span> str + <span class="string">"way"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/(^[^aeiou]+)/</span>, <span class="string">""</span>) + <span class="built_in">RegExp</span>.$<span class="number">1</span> + <span class="string">"ay"</span>;    <span class="comment">// 用/(^[^aeiou]+)/匹配第一个辅音或辅音丛，RegExp.$1用于存储第一个匹配的捕获组</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="DNA-Pairing"><a href="#DNA-Pairing" class="headerlink" title="DNA Pairing"></a>DNA Pairing</h2><p>DNA 链缺少配对的碱基。依据每一个碱基，为其找到配对的碱基，然后将结果作为第二个数组返回。</p>
<p>Base pairs（碱基对） 是一对 AT 和 CG，为给定的字母匹配缺失的碱基。</p>
<p>在每一个数组中将给定的字母作为第一个碱基返回。</p>
<p>1.写一个碱基配对的函数。2.将字符串转化成数组然后使用<code>forEach()</code>方法即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pair</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">basePairs</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (arg) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"A"</span>:</div><div class="line">                arr.push([<span class="string">"A"</span>, <span class="string">"T"</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"T"</span>:</div><div class="line">                arr.push([<span class="string">"T"</span>, <span class="string">"A"</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"C"</span>:</div><div class="line">                arr.push([<span class="string">"C"</span>, <span class="string">"G"</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                arr.push([<span class="string">"G"</span>, <span class="string">"C"</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    str.split(<span class="string">""</span>).forEach(basePairs);</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Missing-letters"><a href="#Missing-letters" class="headerlink" title="Missing letters"></a>Missing letters</h2><p>从传递进来的字母序列中找到缺失的字母并返回它。</p>
<p>如果所有字母都在序列中，返回 undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fearNotLetter</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = str.charCodeAt(<span class="number">0</span>);</div><div class="line">    <span class="keyword">var</span> arr = str.split(<span class="string">""</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = arr.length; i &lt; len; i++) &#123;   <span class="comment">//逐个比较字母</span></div><div class="line">        <span class="keyword">var</span> a = <span class="built_in">String</span>.fromCharCode(num + i);</div><div class="line">        <span class="keyword">if</span> (arr[i] != a) &#123;  <span class="comment">//发现缺失，返回结果</span></div><div class="line">            <span class="keyword">return</span> a;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Boo-who"><a href="#Boo-who" class="headerlink" title="Boo who"></a>Boo who</h2><p>检查一个值是否是基本布尔类型，并返回 true 或 false。</p>
<p>基本布尔类型即 true 和 false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params">bool</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> bool === <span class="string">"boolean"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Sorted-Union"><a href="#Sorted-Union" class="headerlink" title="Sorted Union"></a>Sorted Union</h2><p>写一个 function，传入两个或两个以上的数组，返回一个以给定的原始数组排序的不包含重复值的新数组。</p>
<p>拼接所有数组，遍历数组并去除重复数字。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unite</span>(<span class="params">arr1, arr2, arr3</span>) </span>&#123;</div><div class="line">    <span class="comment">// slice()方法可以用来将一个类数组（Array-like）对象/集合转换成一个数组。你只需将该方法绑定到这个对象上</span></div><div class="line">    <span class="keyword">var</span> argArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">    <span class="comment">// 拼接所有数组</span></div><div class="line">    <span class="keyword">var</span> arr = argArr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">arrA, arrB</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> arrA.concat(arrB);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// index函数返回两个重复数字中后一个数的索引</span></div><div class="line">    <span class="keyword">var</span> index = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> arr.indexOf(arr[arg], arg + <span class="number">1</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 去除重复数字</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">while</span> (index(i) != <span class="number">-1</span>) &#123; arr.splice(index(i), <span class="number">1</span>); &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Convert-HTML-Entities"><a href="#Convert-HTML-Entities" class="headerlink" title="Convert HTML Entities"></a>Convert HTML Entities</h2><p>将字符串中的字符 &amp;、&lt;、&gt;、” （双引号）, 以及 ‘ （单引号）转换为它们对应的 HTML 实体。</p>
<p>直接替换即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>).replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>).replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>).replace(<span class="regexp">/'/g</span>, <span class="string">"&amp;apos;"</span>).replace(<span class="regexp">/"/g</span>, <span class="string">"&amp;quot;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于更多的字符替换，应创建对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    htmlEntities = &#123;</div><div class="line">        <span class="string">'&amp;'</span>: <span class="string">'&amp;amp;'</span>,</div><div class="line">        <span class="string">'&lt;'</span>: <span class="string">'&amp;lt;'</span>,</div><div class="line">        <span class="string">'&gt;'</span>: <span class="string">'&amp;gt;'</span>,</div><div class="line">        <span class="string">'\"'</span>: <span class="string">'&amp;quot;'</span>,</div><div class="line">        <span class="string">'\''</span>: <span class="string">"&amp;apos;"</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> str.split(<span class="string">''</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">entity</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> htmlEntities[entity] || entity;  <span class="comment">// 在字符串中找到了要替换的字符，则替换。</span></div><div class="line">    &#125;).join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Spinal-Tap-Case"><a href="#Spinal-Tap-Case" class="headerlink" title="Spinal Tap Case"></a>Spinal Tap Case</h2><p>将字符串转换为 spinal case。Spinal case 是 all-lowercase-words-joined-by-dashes 这种形式的，也就是以连字符连接所有小写单词。</p>
<p>关键是 <code>spinalCase(&quot;This Is Spinal Tap&quot;)</code> 应该返回 <code>&quot;this-is-spinal-tap&quot;</code>。<br>可以使用正向预搜索：<code>(?=xxxxx)</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spinalCase</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.split(<span class="regexp">/\s|_|(?=[A-Z])/</span>).join(<span class="string">"-"</span>).toLowerCase();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Sum-All-Odd-Fibonacci-Numbers"><a href="#Sum-All-Odd-Fibonacci-Numbers" class="headerlink" title="Sum All Odd Fibonacci Numbers"></a>Sum All Odd Fibonacci Numbers</h2><p>给一个正整数num，返回小于或等于num的斐波纳契奇数之和。</p>
<p>提示：此题不能用递归来实现斐波纳契数列。因为当num较大时，内存会溢出，推荐用数组来实现。</p>
<p>使用数组缓存方法得到斐波纳契数列。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumFibs</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cache = [<span class="number">1</span>, <span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &gt;= cache.length) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = cache.length; i &lt; n ; i++ ) &#123;</div><div class="line">                cache[i] = cache[i - <span class="number">2</span>] + cache[i - <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cache[n - <span class="number">1</span>];</div><div class="line">    &#125;;</div><div class="line">&#125;();</div><div class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; fib(j) &lt;= num; j++) &#123;</div><div class="line">        <span class="keyword">if</span> (fib(j) % <span class="number">2</span>) &#123; sum += fib(j); &#125; &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Sum-All-Primes"><a href="#Sum-All-Primes" class="headerlink" title="Sum All Primes"></a>Sum All Primes</h2><p>求小于等于给定数值的质数之和。</p>
<p>只有 1 和它本身两个约数的数叫质数。例如，2 是质数，因为它只能被 1 和 2 整除。1 不是质数，因为它只能被自身整除。</p>
<p>给定的数不一定是质数。</p>
<p>判断质数，2是质数，其余被2整除的都不是质数，然后依次判断是否能被奇数整除，最大循环为数值的开方。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> === <span class="number">0</span> &amp;&amp; num !== <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">3</span>; i &lt;= <span class="built_in">Math</span>.sqrt(num); i += <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (num % i === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumPrimes</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>; i &lt;= num; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (isPrime(i)) &#123;</div><div class="line">            sum += i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Smallest-Common-Multiple"><a href="#Smallest-Common-Multiple" class="headerlink" title="Smallest Common Multiple"></a>Smallest Common Multiple</h2><p>找出能被两个给定参数和它们之间的连续数字整除的最小公倍数。</p>
<p>范围是两个数字构成的数组，两个数字不一定按数字顺序排序。</p>
<p>用辗转相除法确定两个正整数 a 和 b(a≥b) 的最大公因数gcd(a,b)：当a mod b=0 时gcd(a,b)=b,否则gcd(a,b) = gcd(b,a mod b)递归或循环运算得出结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">smallestCommons</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="comment">// 辗转相除法求最大公约数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (a % b === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> b;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> gcd(b, a % b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 求最小公倍数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">scm</span>(<span class="params">c, d</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> c * d / gcd(c, d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> max = <span class="built_in">Math</span>.max(...arr);</div><div class="line">    <span class="keyword">var</span> min = <span class="built_in">Math</span>.min(...arr);</div><div class="line">    <span class="keyword">var</span> num = min;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= max - min; i++) &#123;</div><div class="line">        num = scm(num, min + i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Finders-Keepers"><a href="#Finders-Keepers" class="headerlink" title="Finders Keepers"></a>Finders Keepers</h2><p>写一个 function，它浏览数组（第一个参数）并返回数组中第一个通过某种方法（第二个参数）验证的元素。</p>
<p>使用<code>filter()</code>方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">arr, func</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.filter(func)[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Drop-it"><a href="#Drop-it" class="headerlink" title="Drop it"></a>Drop it</h2><p>让我们来丢弃数组(arr)的元素，从左边开始，直到回调函数return true就停止。</p>
<p>第二个参数，func，是一个函数。用来测试数组的第一个元素，如果返回fasle，就从数组中抛出该元素(注意：此时数组已被改变)，继续测试数组的第一个元素，如果返回fasle，继续抛出，直到返回true。</p>
<p>最后返回数组的剩余部分，如果没有剩余，就返回一个空数组。</p>
<p><code>drop([1, 2, 3, 4], function(n) {return n &gt;= 3;})</code> 应该返回 <code>[3, 4]</code>。 </p>
<p><code>arr.filter(func)</code>可得到筛选后的数组。然后判断能arr中是否存在筛选后数组的第一项。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">arr, func</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> index = arr.indexOf(arr.filter(func)[<span class="number">0</span>]);    </div><div class="line">    <span class="keyword">return</span> index == <span class="number">-1</span> ? [] : arr.slice(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Steamroller"><a href="#Steamroller" class="headerlink" title="Steamroller"></a>Steamroller</h2><p>对嵌套的数组进行扁平化处理。你必须考虑到不同层级的嵌套。</p>
<p><code>steamroller([1, [2], [3, [[4]]]])</code> 应该返回 <code>[1, 2, 3, 4]</code>。 </p>
<p><code>steamroller([1, {}, [3, [[4]]]])</code> 应该返回 <code>[1, {}, 3, 4]</code>。 </p>
<p>写一个扁平化处理的函数，将非数组的项收集到一个新数组，对于数组项，循环调用该函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">steamroller</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newArr = [];</div><div class="line">    <span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arg)) &#123; newArr.push(arg); &#125; <span class="keyword">else</span> &#123; arg.forEach(flatten); &#125;</div><div class="line">    &#125;;</div><div class="line">    arr.forEach(flatten);</div><div class="line">    <span class="keyword">return</span> newArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Binary-Agents"><a href="#Binary-Agents" class="headerlink" title="Binary Agents"></a>Binary Agents</h2><p>传入二进制字符串，翻译成英语句子并返回。</p>
<p>二进制字符串是以空格分隔的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryAgent</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    biString = str.split(<span class="string">' '</span>);</div><div class="line">    <span class="keyword">var</span> uniString = [];</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>,len=biString.length; i &lt; len; i++) &#123;</div><div class="line">        uniString.push(<span class="built_in">String</span>.fromCharCode(<span class="built_in">parseInt</span>(biString[i], <span class="number">2</span>)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> uniString.join(<span class="string">""</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Everything-Be-True"><a href="#Everything-Be-True" class="headerlink" title="Everything Be True"></a>Everything Be True</h2><p>完善编辑器中的every函数，如果集合(collection)中的所有对象都存在对应的属性(pre)，并且属性(pre)对应的值为真。函数返回ture。反之，返回false。</p>
<p>使用<code>every()</code>方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">every</span>(<span class="params">collection, pre</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> collection.every(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> item.hasOwnProperty(pre) &amp;&amp; item[pre];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Arguments-Optional"><a href="#Arguments-Optional" class="headerlink" title="Arguments Optional"></a>Arguments Optional</h2><p>创建一个计算两个参数之和的 function。如果只有一个参数，则返回一个 function，该 function 请求一个参数然后返回求和的结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//检查参数是否为有效数字</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkNum</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> num != <span class="string">"number"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>; &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> num; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//一个参数情况</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">var</span> a = checkNum(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">if</span> (a) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (checkNum(arg)) &#123;</div><div class="line">                    <span class="keyword">return</span> a + arg; &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">undefined</span>; &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//其他情况</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">var</span> b = checkNum(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">var</span> c = checkNum(<span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">        <span class="keyword">if</span> (b &amp;&amp; c) &#123;</div><div class="line">            <span class="keyword">return</span> b + c; &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考资料：<a href="https://forum.freecodecamp.com/c/wiki" target="_blank" rel="external">https://forum.freecodecamp.com/c/wiki</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.freecodecamp.cn/&quot; target=&quot;_blank&quot;&gt;freeCodeCamp&lt;/a&gt;中级算法题整理解析。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://www.yinfengblog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序和搜索算法</title>
    <link href="http://www.yinfengblog.com/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://www.yinfengblog.com/排序和搜索算法/</id>
    <published>2017-02-25T13:42:33.000Z</published>
    <updated>2017-04-06T15:31:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习常见的排序和搜索算法。<br><a id="more"></a> </p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> len = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</div><div class="line">                [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (arr);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> len = arr.length,</div><div class="line">        minIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">        minIndex = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</div><div class="line">                minIndex = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (arr);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> len = arr.length,</div><div class="line">        preIndex = <span class="number">0</span>,</div><div class="line">        current = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        preIndex = i - <span class="number">1</span>;</div><div class="line">        current = arr[i];</div><div class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</div><div class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</div><div class="line">            preIndex--;</div><div class="line">        &#125;</div><div class="line">        arr[preIndex + <span class="number">1</span>] = current;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (arr);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> len = arr.length;</div><div class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</div><div class="line">        left = arr.slice(<span class="number">0</span>, middle),</div><div class="line">        right = arr.slice(middle);</div><div class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = [];</div><div class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</div><div class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</div><div class="line">            result.push(left.shift());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.push(right.shift());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (left.length)</div><div class="line">        result.push(left.shift());</div><div class="line">    <span class="keyword">while</span> (right.length)</div><div class="line">        result.push(right.shift());</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>从数列中挑出一个元素，称为 “基准”;</p>
<p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作；</p>
<p>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">        <span class="keyword">let</span> partitionIndex = partition(arr, left, right);</div><div class="line">        quickSort(arr, left, partitionIndex - <span class="number">1</span>);</div><div class="line">        quickSort(arr, partitionIndex + <span class="number">1</span>, right);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> pivot = left,</div><div class="line">        index = pivot + <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= right; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</div><div class="line">            [arr[i], arr[index]] = [arr[index], arr[i]];</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    [arr[pivot], arr[index - <span class="number">1</span>]] = [arr[index - <span class="number">1</span>], arr[pivot]];</div><div class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="顺序搜索"><a href="#顺序搜索" class="headerlink" title="顺序搜索"></a>顺序搜索</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequentialSearch</span>(<span class="params">arr, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (item === arr[i])</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>这个算法要求被搜索的数据结构已排序。</p>
<ol>
<li>选择数组的中间值。</li>
<li>如果选中值是待搜索值，那么算法执行完毕。</li>
<li>如果待搜索值n比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。</li>
<li>如果待搜索值n比选中值要大，则返回步骤1并在选中值右边的子数组中寻找。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> low = <span class="number">0</span>,</div><div class="line">        high = arr.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</div><div class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</div><div class="line">        <span class="keyword">if</span> (value &gt; arr[mid]) &#123;</div><div class="line">            low = mid + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; arr[mid]) &#123;</div><div class="line">            high = mid - <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习常见的排序和搜索算法。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://www.yinfengblog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>理解词法作用域与闭包</title>
    <link href="http://www.yinfengblog.com/%E7%90%86%E8%A7%A3%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>http://www.yinfengblog.com/理解词法作用域与闭包/</id>
    <published>2017-02-12T02:31:45.000Z</published>
    <updated>2017-02-20T03:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>阅读了《你不知道的JavaScript》上卷，结合《高程》，对词法作用域、闭包及模块模式做一个简单的总结。<br><a id="more"></a><br>理解词法作用域可以让我们更好的理解闭包。而学习词法作用域需要对编译的步骤有所了解。</p>
<h2 id="关于编译原理"><a href="#关于编译原理" class="headerlink" title="关于编译原理"></a>关于编译原理</h2><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p>
<ul>
<li>分词/词法分析</li>
</ul>
<p>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代<br>码块被称为词法单元（token）。例如，考虑程序var a = 2;。这段程序通常会被分解成<br>为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在<br>这门语言中是否具有意义。</p>
<ul>
<li>解析/语法分析</li>
</ul>
<p>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法<br>结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。<br>var a = 2; 的抽象语法树中可能会有一个叫作VariableDeclaration 的顶级节点，接下<br>来是一个叫作Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression<br>的子节点。AssignmentExpression 节点有一个叫作NumericLiteral（它的值是2）的子<br>节点。</p>
<ul>
<li>代码生成</li>
</ul>
<p>将AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息<br>息相关。<br>抛开具体细节，简单来说就是有某种方法可以将var a = 2; 的AST 转化为一组机器指<br>令，用来创建一个叫作a 的变量（包括分配内存等），并将一个值储存在a 中。</p>
<p>比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化。</p>
<p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域。另外一种叫作动态作用域。</p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。with和eval除外，所以只能说JS的作用域机制非常接近词法作用域。</p>
<p><strong> 闭包是基于词法作用域书写代码时所产生的自然结果 </strong></p>
<h2 id="典型的闭包："><a href="#典型的闭包：" class="headerlink" title="典型的闭包："></a>典型的闭包：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> baz = foo();</div><div class="line">baz();</div></pre></td></tr></table></figure>
<p>函数bar() 的词法作用域能够访问foo() 的内部作用域。然后我们将bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将bar 所引用的函数对象本身当作返回值。</p>
<p>在foo() 执行后，其返回值（也就是内部的bar() 函数）赋值给变量baz 并调用baz()，实际上只是通过不同的标识符引用调用了内部的函数bar()。</p>
<p>bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行，而且它可以访问定义时的词法作用域，因此可以访问变量a。</p>
<p><strong> 闭包与词法作用域的关系 </strong>：无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</p>
<h2 id="闭包与Module模式"><a href="#闭包与Module模式" class="headerlink" title="闭包与Module模式"></a>闭包与Module模式</h2><p>模块模式使用闭包封装‘私有’状态和组织。它提供了一种包装混合公有/私有方法和变量的方式，防止其泄露至全局作用域，并与别的开发人员的接口发生冲突。通过该模式，只需返回一个公有API，而其他的一切则都维持在私有的闭包里。</p>
<p>模块模式的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myModule = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 私有变量和私有函数</span></div><div class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//共有方法和属性</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">publicProperty</span>: <span class="literal">true</span>,</div><div class="line"></div><div class="line">        <span class="attr">publicMethod</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            privateVariable++;</div><div class="line">            <span class="keyword">return</span> privateFunction();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>闭包的一个很重要的作用就是隐藏变量和函数。</p>
<p>如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。</p>
<h2 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h2><p>创建闭包必须维护额外的作用域，过度使用它们可能会占用大量内存。</p>
<p>由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中可能会导致内存泄漏</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读了《你不知道的JavaScript》上卷，结合《高程》，对词法作用域、闭包及模块模式做一个简单的总结。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.yinfengblog.com/categories/JavaScript/"/>
    
    
      <category term="闭包" scheme="http://www.yinfengblog.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记（一）</title>
    <link href="http://www.yinfengblog.com/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.yinfengblog.com/ES6学习笔记/</id>
    <published>2017-02-10T05:27:55.000Z</published>
    <updated>2017-03-18T08:33:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习阮一峰著《ECMAScript 6 入门》，根据<em>自己的学习情况</em>进行了整理，方便查找复习。<br><a id="more"></a> </p>
<h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><p>ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。</p>
<h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><p>在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。</p>
<p>const 的定义是不可重新赋值的值，与不可变的值(immutable value)不同；const 定义的 Object，在定义之后仍可以修改其属性。</p>
<p>所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以const做定义。反之就 let 而言，他的使用场景应该是相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</div><div class="line"><span class="keyword">const</span> c = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div></pre></td></tr></table></figure>
<p>所有的函数都应该设置为常量。</p>
<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><p>使用数组成员对变量赋值时，优先使用解构赋值。<br>函数的参数如果是对象的成员，优先使用解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> firstName = user.firstName;</div><div class="line">  <span class="keyword">const</span> lastName = user.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; firstName, lastName &#125; = obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [left, right, top, bottom];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; left, right, top, bottom &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; left, right &#125; = processInput(input);</div></pre></td></tr></table></figure></p>
<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(),startsWith(),endsWith()"></a>includes(),startsWith(),endsWith()</h3><ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。<br>这三个方法都支持第二个参数，表示开始搜索的位置。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;</div><div class="line"></div><div class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></div><div class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></div><div class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### padStart(),padEnd()</div><div class="line">padStart的常见用途是为数值补全指定位数。</div><div class="line">另一个用途是提示字符串格式。</div><div class="line">```javascript</div><div class="line">&apos;12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;) // &quot;YYYY-MM-12&quot;</div><div class="line">&apos;09-12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;) // &quot;YYYY-09-12&quot;</div></pre></td></tr></table></figure>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></div><div class="line">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</div><div class="line">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure></p>
<h2 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h2><h3 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h3><p>“粘连”修饰符<br>y修饰符号隐含了头部匹配的标志^。<br>y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。</p>
<h3 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h3><p>目前，有一个提案，在ES7加入后行断言。V8引擎4.9版已经支持，Chrome浏览器49版打开”experimental JavaScript features“开关（地址栏键入about:flags），就可以使用这项功能。</p>
<p>“后行断言”正好与”先行断言”相反，x只有在y后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>。”后行否定断言“则与”先行否定断言“相反，x只有不在y后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\$)\d+/</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/(?&lt;=\$)\d+/.exec('Benjamin Franklin is on the $100 bill')  // ["100"]</div><div class="line">/(?&lt;!\$)\d+/.exec('it’s is worth about €90')                // ["90"]</div></pre></td></tr></table></figure>
<p>“后行断言”的组匹配，与正常情况下结果是不一样的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/(?&lt;=(\d+)(\d+))$/.exec('1053') // ["", "1", "053"]</div><div class="line">/^(\d+)(\d+)$/.exec('1053') // ["1053", "105", "3"]</div></pre></td></tr></table></figure></p>
<p>上面代码中，需要捕捉两个组匹配。没有”后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而”后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。</p>
<p>其次，”后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/(?&lt;=(o)d\1)r/.exec('hodor')  // null</div><div class="line">/(?&lt;=\1d(o))r/.exec('hodor')  // ["r", "o"]</div></pre></td></tr></table></figure></p>
<p>上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。</p>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><h3 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h3><ul>
<li>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</li>
<li>Math.sign方法用来判断一个数到底是正数、负数、还是零。</li>
<li>Math.cbrt方法用于计算一个数的立方根。</li>
</ul>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<p>扩展运算符（…）也可以将某些数据结构转为数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// arguments对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = [...arguments];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NodeList对象</span></div><div class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</div></pre></td></tr></table></figure></p>
<p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</p>
<h3 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<h3 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h3><p>fill方法使用给定值，填充一个数组。</p>
<h3 id="数组实例的entries-keys-和values"><a href="#数组实例的entries-keys-和values" class="headerlink" title="数组实例的entries(),keys()和values()"></a>数组实例的entries(),keys()和values()</h3><p>ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<h3 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h3><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。</p>
<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>如果参数默认值是变量，那么参数就不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(method);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fetch(<span class="string">'http://example.com'</span>, &#123;&#125;)</div><div class="line"><span class="comment">// "GET"</span></div><div class="line"></div><div class="line">fetch(<span class="string">'http://example.com'</span>)</div><div class="line"><span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。</p>
<p>上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; method = <span class="string">'GET'</span> &#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(method);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fetch(<span class="string">'http://example.com'</span>)</div><div class="line"><span class="comment">// "GET"</span></div></pre></td></tr></table></figure></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中</p>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级。</p>
<p>箭头函数转成ES5的代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, _this.id);</div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="绑定this"><a href="#绑定this" class="headerlink" title="绑定this"></a>绑定this</h3><p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。<br>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</div><div class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</div><div class="line">&#125;</div><div class="line"></div><div class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></div></pre></td></tr></table></figure>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p><code>Object.is(NaN, NaN) // true</code></p>
<h3 id="Objects-assign"><a href="#Objects-assign" class="headerlink" title="Objects.assign()"></a>Objects.assign()</h3><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）<br>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。</p>
<ol>
<li><p>合并多个对象<br>将多个对象合并到某个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> merge =</div><div class="line">  <span class="function">(<span class="params">target, ...sources</span>) =&gt;</span> <span class="built_in">Object</span>.assign(target, ...sources);</div></pre></td></tr></table></figure>
</li>
<li><p>为属性指定默认值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> DEFAULTS = &#123;</div><div class="line">  <span class="attr">logLevel</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">outputFormat</span>: <span class="string">'html'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">  options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>由于存在深拷贝的问题，DEFAULTS对象和options对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致DEFAULTS对象的该属性不起作用。</p>
<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p>ES6一共有5种方法可以遍历对象的属性。</p>
<p>（1）for…in</p>
<p>for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p>
<p>（2）Object.keys(obj)</p>
<p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</p>
<p>（3）Object.getOwnPropertyNames(obj)</p>
<p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</p>
<p>（4）Object.getOwnPropertySymbols(obj)</p>
<p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</p>
<p>（5）Reflect.ownKeys(obj)</p>
<p>Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</p>
<p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有属性名为数值的属性，按照数字排序。</li>
<li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li>
<li>最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</li>
</ul>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>Object.setPrototypeOf方法用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习阮一峰著《ECMAScript 6 入门》，根据&lt;em&gt;自己的学习情况&lt;/em&gt;进行了整理，方便查找复习。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.yinfengblog.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://www.yinfengblog.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>学习跨域请求解决方案(CORS、JSONP)</title>
    <link href="http://www.yinfengblog.com/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://www.yinfengblog.com/学习前端跨域解决方案/</id>
    <published>2017-02-06T12:21:39.000Z</published>
    <updated>2017-02-20T01:32:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>结合自己之前demo中的AJAX来学习前端跨域方法。<br><a id="more"></a> </p>
<h1 id="跨域问题由来"><a href="#跨域问题由来" class="headerlink" title="跨域问题由来"></a>跨域问题由来</h1><p> 前端处于项目开发过程中最接近用户的一个区域，代码最容易被hack获取解析，也最容易受到攻击。<br>因此，通过XHR实现AJAX通信的一个主要限制，来源于同源策略：浏览器限制脚本中发起的跨站请求，<br>要求JavaScript或cookie只能访问同源的资源。<br>这里的同源指的是域名，协议名，以及端口号相同。</p>
<h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><p>JS里实现跨域的几种方法：CORS（跨域资源共享）、JSONP、cross-document messaging（跨文档消息传递）、Web Sockets、<br>iframe跨域以及服务器代理。</p>
<p>这里先总结CORS和JSONP。</p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS是W3C推荐的一个让Web应用服务器能支持跨域访问控制，从而使得安全地进行跨域数据传输的标准。CORS背后的基本思想，<br>就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>
<p>使用CORS跨域的时候和普通的AJAX过程是一样的。浏览器一但发现AJAX请求跨域资源，就会自动添加一些请求头帮助我们处理一些事情。所以说只要服务端提供CORS支持，前端不需要做额外的事情。</p>
<p>CORS请求分两种，简单请求和非简单请求。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>简单请求满足的条件：</p>
<p>（1） 请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>（3）不使用自定义请求头</p>
<p>简单请求与同源时发送的请求差不多，不过在服务器端要明确Access-Control-Allow-Origin字段的值，以使请求的数据顺利返回客户端。</p>
<p>另外，客户端发现AJAX发送的是跨域请求，会在请求头中自动添加一个Origin字段。</p>
<p>结合之前自己做的demo，利用维基百科的API查询维基百科条目，请求的数据顺利返回，部分头部信息如下：<br><img src="http://p1.bqimg.com/582196/72d864ff72ede8a3.png"></p>
<p>Access-Control-Allow-Origin: 该字段为必需字段，可以是指定的源名（协议+域名+端口），也可以使用通配符*代表接受所有跨域资源请求。<br>如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。</p>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。这种请求使用OPTIONS方法，发送<br>这个请求后，服务器可以决定是否允许这种类型的请求。如果是才真正发送指定方式的请求。</p>
<p>结合自己的另一个<a href="http://yinfengblog.com/Random-Quote-Machine/" target="_blank" rel="external">demo</a>，部分代码及头部信息如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    <span class="attr">headers</span>: &#123; <span class="string">"X-Mashape-Key"</span>: <span class="string">"MLHtOdrnY5mshXxPTKg6YoqX0LBPp1Ywu3mjsnj8236K9zbKiI"</span> &#125;,</div><div class="line">    <span class="attr">url</span>: <span class="string">'https://andruxnet-random-famous-quotes.p.mashape.com/cat='</span>,</div><div class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">        <span class="comment">// 请求成功后的处理</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><img src="http://i1.piimg.com/582196/7caa3db0ba1819c4.png"><br><img src="http://p1.bqimg.com/582196/06e897781a55c7d2.png"></p>
<ul>
<li><p>Access-Control-Allow-Methods: 指明请求的可用方式有哪些(一个或者多个，不同方法之间用英文逗号隔开)。这个响应头信息作为对客户端发出的预检请求中Access-Control-Request-Method的回复，必含。 </p>
</li>
<li><p>Access-Control-Allow-Headers: 在响应预检请求的时候使用。用来指明在实际的请求中，可以使用哪些自定义HTTP请求头，那么在客户端发送请求时就可以加上这些可以使用的自定义请求头。</p>
</li>
<li><p>Access-Control-Request-Headers: 在发出预检请求时带有这个头信息，告诉服务器在实际请求时会携带的自定义头信息。如有多个，可以用逗号分开。<br><strong>在这个例子中为x-masshape-key，是在JS代码中指定的自定义的头信息，这里是使用这个公共API的APPKey的名字。</strong></p>
</li>
<li><p>Access-Control-Request-Mrthod: 在发出预检请求时带有这个头信息,告诉服务器在实际请求时会使用的请求方式。</p>
</li>
<li><p>Origin: 表明发送请求或者预检请求的域，值是一个URI，告诉服务器端,请求来自哪里。它不包含任何路径信息，只是协议 + 域名 + 端口。Origin的值也可以是一个空字符串。<br><strong>在这里与Access-Control-Allow-Origin值一样，为博客地址，可以说预检请求通过了，可以发送实际请求。</strong></p>
</li>
</ul>
<p>Preflight请求结束后，结果将按照响应中指定的时间缓存起来。以后每次浏览器正常的CORS（跨域）请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p>实际请求：<br><img src="http://i1.piimg.com/582196/a3e7cb96dda319d2.png"><br><img src="http://i1.piimg.com/582196/42dcbd40a3c28129.png"></p>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>JSONP是JSON with padding (填充式JSON或参数式JSON)的简写。</p>
<p>JSONP由两部分组成：回调函数和数据。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。</p>
<p>JSONP 是通过动态<code>&lt;script&gt;</code>元素来使用的，使用时可以为src属性指定一个跨域URL。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>利用百度地图API获取所在城市：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> myCity = <span class="keyword">new</span> BMap.LocalCity();</div><div class="line">    myCity.get(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> cityname = r.name;</div><div class="line">        getWeather(cityname);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">script.src = <span class="string">'https://api.map.baidu.com/api?v=2.0&amp;ak=kKC3PPnZc3Fq7xlwGyZfkCuYnGBrGuAL&amp;callback=initialize'</span>;</div><div class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</div></pre></td></tr></table></figure>
<p>JSONP也可以通过jQuery的getJSON()方法实现。下面利用百度地图的数据，获取聚合数据给出的城市天气信息：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWeather</span>(<span class="params">cityname</span>) </span>&#123;</div><div class="line">    $.getJSON(<span class="string">"https://v.juhe.cn/weather/index?callback=?"</span>, &#123;</div><div class="line">        <span class="string">"cityname"</span>: cityname,</div><div class="line">        <span class="string">"dtype"</span>: <span class="string">"jsonp"</span>,</div><div class="line">        <span class="string">"key"</span>: <span class="string">"12787276c08fd9a6d9c249a6189f59d9"</span></div><div class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">       <span class="comment">// 获取需要的天气信息</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>它只支持GET请求而不支持POST等其它类型的HTTP请求</li>
<li>它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题</li>
<li>JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码</li>
<li>难以判断JSONP请求是否失败</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结合自己之前demo中的AJAX来学习前端跨域方法。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.yinfengblog.com/categories/JavaScript/"/>
    
    
      <category term="跨域" scheme="http://www.yinfengblog.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>不会输的井字棋</title>
    <link href="http://www.yinfengblog.com/%E4%B8%8D%E4%BC%9A%E8%BE%93%E7%9A%84%E4%BA%95%E5%AD%97%E6%A3%8B/"/>
    <id>http://www.yinfengblog.com/不会输的井字棋/</id>
    <published>2017-01-26T06:56:53.000Z</published>
    <updated>2017-01-27T16:39:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript练手项目——带有AI的井字棋"><a href="#JavaScript练手项目——带有AI的井字棋" class="headerlink" title="JavaScript练手项目——带有AI的井字棋"></a>JavaScript练手项目——<a href="http://yinfengblog.com/Tic-Tac-Toe/" target="_blank" rel="external">带有AI的井字棋</a></h3><a id="more"></a> 
<p>井字棋是一个很简单的游戏，通过穷举，我们轻易的记录井字棋所有可能的走法。因此我们的AI可以实现的能力是</p>
<p><strong>先手：尽可能的赢棋</strong></p>
<p><strong>后手：保证不输棋，且在玩家出现失误的情况下赢棋</strong></p>
<h3 id="游戏基本功能"><a href="#游戏基本功能" class="headerlink" title="游戏基本功能"></a>游戏基本功能</h3><p>1.有一个下棋（落子）的函数</p>
<p>2.有一个判断胜负的函数</p>
<h3 id="AI部分"><a href="#AI部分" class="headerlink" title="AI部分"></a>AI部分</h3><p><em>穷举后，可知</em></p>
<p>作为先手，只要占下一个拐角，玩家在剩下的8个位置中，有7个是必输的。剩下的一种方式，也最多只是平手。</p>
<p>作为后手则更加简单，无论玩家怎么开局，只要AI走对了前两步棋，后面就只要专门拦住玩家的棋即可。</p>
<p>所以需要</p>
<p>1.根据玩家下子的情况，让AI下特定的位置（只需两步）。</p>
<p><strong>2.有一个进攻函数来连成三子取得胜利，用于抓住玩家的失误或者防止玩家放水。有一个防守函数来拦住玩家的棋子，使之不能连成三子。</strong></p>
<p>3.有一个随机下子函数来在要平局的情况下填满棋盘。</p>
<p>优先级：进攻&gt;防守&gt;随机</p>
<hr>

<p><strong> 戳<a href="http://yinfengblog.com/Tic-Tac-Toe/" target="_blank" rel="external">这里</a>试用 </strong></p>
<h3 id="部分JS代码："><a href="#部分JS代码：" class="headerlink" title="部分JS代码："></a>部分JS代码：</h3><p>棋盘数组，用于判断胜负和进攻防守函数。<br><code>arr = [[0, 1, 2],[0, 3, 6],[1, 4, 7],[2, 5, 8],[3, 4, 5],[6, 7, 8],[0, 4, 8],[2, 4, 6]]</code></p>
<p>判断胜负函数<em>(棋子设置了自定义属性，只要任意一条线上拼接起来为”111”则代表连成一线，由于玩家不会赢，不需要判断玩家是否胜利)</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkSituation</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">if</span> (arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">             <span class="keyword">return</span> concatBox(item) == <span class="string">"111"</span>;</div><div class="line">         &#125;)) &#123;</div><div class="line">         result(<span class="string">"你输了 :-("</span>);</div><div class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($(<span class="string">"button[disabled]"</span>).length === <span class="number">9</span>) &#123;</div><div class="line">         result(<span class="string">"平局"</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>进攻函数，防守函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  "0"为空子，"1"为AI棋子，"-1"为玩家棋子</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">attack</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (concatBox(arr)) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"011"</span>:</div><div class="line">                aiClick(arr[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"101"</span>:</div><div class="line">                aiClick(arr[<span class="number">1</span>]);</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"110"</span>:</div><div class="line">                aiClick(arr[<span class="number">2</span>]);</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">defense</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (concatBox(arr)) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"0-1-1"</span>:</div><div class="line">                aiClick(arr[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"-10-1"</span>:</div><div class="line">                aiClick(arr[<span class="number">1</span>]);</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"-1-10"</span>:</div><div class="line">                aiClick(arr[<span class="number">2</span>]);</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>AI下棋函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">aiRound</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">//  连三子</span></div><div class="line">    <span class="keyword">if</span> (arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> attack(item);</div><div class="line">        &#125;)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//  拦住玩家三子</span></div><div class="line">    <span class="keyword">if</span> (arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> defense(item);</div><div class="line">        &#125;)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//  AI先手</span></div><div class="line">    <span class="keyword">if</span> (AI === <span class="string">"X"</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (aiSteps === <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</div><div class="line">                <span class="keyword">case</span> box(<span class="number">1</span>) == <span class="number">-1</span> || box(<span class="number">3</span>) == <span class="number">-1</span>:</div><div class="line">                    Xcase = <span class="string">"1"</span>;</div><div class="line">                    aiClick(<span class="number">4</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> box(<span class="number">2</span>) == <span class="number">-1</span> || box(<span class="number">6</span>) == <span class="number">-1</span>:</div><div class="line">                    Xcase = <span class="string">"2"</span>;</div><div class="line">                    aiClick(<span class="number">8</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> box(<span class="number">5</span>) == <span class="number">-1</span> || box(<span class="number">7</span>) == <span class="number">-1</span>:</div><div class="line">                    Xcase = <span class="string">"3"</span>;</div><div class="line">                    aiClick(<span class="number">4</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> box(<span class="number">8</span>) == <span class="number">-1</span>:</div><div class="line">                    Xcase = <span class="string">"4"</span>;</div><div class="line">                    aiClick(<span class="number">2</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    aiClick(<span class="number">8</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (aiSteps === <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">switch</span> (Xcase) &#123;</div><div class="line">                <span class="keyword">case</span> <span class="string">"1"</span>:</div><div class="line">                    <span class="keyword">if</span> (box(<span class="number">3</span>) == <span class="number">-1</span>) &#123; aiClick(<span class="number">2</span>); &#125; <span class="keyword">else</span> &#123; aiClick(<span class="number">6</span>); &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="string">"2"</span>:</div><div class="line">                    <span class="keyword">if</span> (box(<span class="number">2</span>) == <span class="number">-1</span>) &#123; aiClick(<span class="number">6</span>); &#125; <span class="keyword">else</span> &#123; aiClick(<span class="number">2</span>); &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="string">"3"</span>:</div><div class="line">                    <span class="keyword">if</span> (box(<span class="number">5</span>) == <span class="number">-1</span>) &#123; aiClick(<span class="number">2</span>); &#125; <span class="keyword">else</span> &#123; aiClick(<span class="number">6</span>); &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="string">"4"</span>:</div><div class="line">                    aiClick(<span class="number">6</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//  AI后手</span></div><div class="line">    <span class="keyword">if</span> (AI === <span class="string">"O"</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (aiSteps === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (box(<span class="number">4</span>) == <span class="number">-1</span>) &#123;</div><div class="line">                aiClick(<span class="number">0</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                aiClick(<span class="number">4</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aiSteps === <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">parseInt</span>(box(<span class="number">0</span>)) + <span class="built_in">parseInt</span>(box(<span class="number">2</span>)) + <span class="built_in">parseInt</span>(box(<span class="number">6</span>)) + <span class="built_in">parseInt</span>(box(<span class="number">8</span>)) == <span class="number">2</span>) &#123; aiClick(<span class="number">1</span>); &#125; </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (twoBox(<span class="number">2</span>, <span class="number">3</span>) || twoBox(<span class="number">1</span>, <span class="number">6</span>) || twoBox(<span class="number">1</span>, <span class="number">3</span>)) &#123; aiClick(<span class="number">0</span>); &#125; </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (twoBox(<span class="number">0</span>, <span class="number">5</span>) || twoBox(<span class="number">1</span>, <span class="number">8</span>) || twoBox(<span class="number">1</span>, <span class="number">5</span>)) &#123; aiClick(<span class="number">2</span>); &#125; </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (twoBox(<span class="number">0</span>, <span class="number">7</span>) || twoBox(<span class="number">3</span>, <span class="number">8</span>) || twoBox(<span class="number">3</span>, <span class="number">7</span>)) &#123; aiClick(<span class="number">6</span>); &#125; </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (twoBox(<span class="number">5</span>, <span class="number">7</span>) || twoBox(<span class="number">5</span>, <span class="number">6</span>) || twoBox(<span class="number">2</span>, <span class="number">7</span>)) &#123; aiClick(<span class="number">8</span>); &#125; </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (twoBox(<span class="number">0</span>, <span class="number">8</span>) || twoBox(<span class="number">2</span>, <span class="number">6</span>)) &#123; aiClick(<span class="number">1</span>); &#125; </div><div class="line">            <span class="keyword">else</span> &#123; aiClick(<span class="number">2</span>); &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aiSteps === <span class="number">2</span> || aiSteps === <span class="number">3</span>) &#123; randomStep(); &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JavaScript练手项目——带有AI的井字棋&quot;&gt;&lt;a href=&quot;#JavaScript练手项目——带有AI的井字棋&quot; class=&quot;headerlink&quot; title=&quot;JavaScript练手项目——带有AI的井字棋&quot;&gt;&lt;/a&gt;JavaScript练手项目——&lt;a href=&quot;http://yinfengblog.com/Tic-Tac-Toe/&quot;&gt;带有AI的井字棋&lt;/a&gt;&lt;/h3&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.yinfengblog.com/categories/JavaScript/"/>
    
    
      <category term="demo" scheme="http://www.yinfengblog.com/tags/demo/"/>
    
  </entry>
  
  <entry>
    <title>FCC初级编程题整理</title>
    <link href="http://www.yinfengblog.com/FCC%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://www.yinfengblog.com/FCC初级算法题整理/</id>
    <published>2017-01-19T08:06:37.000Z</published>
    <updated>2017-03-27T13:53:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.freecodecamp.cn/" target="_blank">freeCodeCamp</a>前端部分快完成了。来整理一下<a href="https://www.freecodecamp.cn/" target="_blank">freeCodeCamp</a>的算法题。这些题都相对简单，用来熟悉API的使用。这篇文章选了部分初级算法题进行整理。<br><a id="more"></a><br>这些是初学时做的题，毕竟当时写的代码太蠢<em>(:з)∠)</em>，有些改成了更好的写法。</p>
<h2 id="Reverse-a-String-翻转字符串"><a href="#Reverse-a-String-翻转字符串" class="headerlink" title="Reverse a String(翻转字符串)"></a>Reverse a String(翻转字符串)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Factorialize-a-Number-阶乘"><a href="#Factorialize-a-Number-阶乘" class="headerlink" title="Factorialize a Number(阶乘)"></a>Factorialize a Number(阶乘)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">factorialize</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line">    <span class="keyword">return</span> num * factorialize(num - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Check-for-Palindromes-回文检测"><a href="#Check-for-Palindromes-回文检测" class="headerlink" title="Check for Palindromes(回文检测)"></a>Check for Palindromes(回文检测)</h2><p>  如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">palindrome</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> originStr = str.replace(<span class="regexp">/[\W_]/g</span>, <span class="string">""</span>).toLowerCase(); <span class="comment">//  /[\W_]/g匹配所有的字母、数字以外的字符</span></div><div class="line">    <span class="keyword">var</span> newStr = originStr.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</div><div class="line">    <span class="keyword">return</span> newStr === originStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Find-the-Longest-Word-in-a-String"><a href="#Find-the-Longest-Word-in-a-String" class="headerlink" title="Find the Longest Word in a String"></a>Find the Longest Word in a String</h2><p>  找到提供的句子中最长的单词，并计算它的长度。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLongestWord</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> s.split(<span class="string">' '</span>)</div><div class="line">        .reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.max(x, y.length);</div><div class="line">        &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Title-Case-a-Sentence-Incomplete"><a href="#Title-Case-a-Sentence-Incomplete" class="headerlink" title="Title Case a Sentence Incomplete   "></a>Title Case a Sentence Incomplete   </h2><p>  确保字符串的每个单词首字母都大写，其余部分小写。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleCase</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.toLowerCase().replace(<span class="regexp">/( |^)[a-z]/g</span>, (L) =&gt; L.toUpperCase());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Truncate-a-String"><a href="#Truncate-a-String" class="headerlink" title="Truncate a String"></a>Truncate a String</h2><p>  如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。插入到字符串尾部的三个点号也会计入字符串的长度。但是果指<br>定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">str, num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">3</span> &amp;&amp; str.length &gt; num) &#123; str = str.slice(<span class="number">0</span>, num) + <span class="string">"..."</span>; &#125; </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (str.length &gt; num) &#123; str = str.slice(<span class="number">0</span>, num - <span class="number">3</span>) + <span class="string">"..."</span>; &#125;</div><div class="line">    <span class="keyword">return</span> str;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h2><p>  如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">str, num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">3</span> &amp;&amp; str.length &gt; num) &#123; str = str.slice(<span class="number">0</span>, num) + <span class="string">"..."</span>; &#125; </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (str.length &gt; num) &#123; str = str.slice(<span class="number">0</span>, num - <span class="number">3</span>) + <span class="string">"..."</span>; &#125;</div><div class="line">    <span class="keyword">return</span> str;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Seek-and-Destroy"><a href="#Seek-and-Destroy" class="headerlink" title="Seek and Destroy"></a>Seek and Destroy</h2><p>  实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyer</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arg = <span class="built_in">arguments</span>;</div><div class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len=arr.length; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (item == arg[i]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Where-do-I-belong"><a href="#Where-do-I-belong" class="headerlink" title="Where do I belong"></a>Where do I belong</h2><p>  先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。<br>  where([20,3,5], 19) 应该返回2。因为数组会先排序为[3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">where</span>(<span class="params">arr, num</span>) </span>&#123;</div><div class="line">    arr.push(num);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value1 - value2;</div><div class="line">    &#125;</div><div class="line">    arr.sort(compare);</div><div class="line">    <span class="keyword">return</span> arr.indexOf(num);    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Caesars-Cipher"><a href="#Caesars-Cipher" class="headerlink" title="Caesars Cipher"></a>Caesars Cipher</h2><p>  下面我们来介绍风靡全球的凯撒密码Caesar cipher，又叫移位密码。移位密码也就是密码中的字母会按照指定的数量来做移位。<br>  一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。<br>  写一个ROT13函数，实现输入加密字符串，输出解密字符串。<br>所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">rot13</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.split(<span class="string">''</span>)</div><div class="line">        .map(<span class="function"><span class="keyword">function</span>(<span class="params">char</span>) </span>&#123;</div><div class="line">            x = char.charCodeAt(<span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (x &lt; <span class="number">65</span> || x &gt; <span class="number">90</span>) &#123; </div><div class="line">                <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(x);  <span class="comment">//非大写字母</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">78</span>) &#123; </div><div class="line">                <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(x + <span class="number">13</span>);  <span class="comment">//前13个大写字母右移13位</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(x - <span class="number">13</span>);  <span class="comment">//后13个大写字母左移13位</span></div><div class="line">        &#125;).join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.freecodecamp.cn/&quot; target=&quot;_blank&quot;&gt;freeCodeCamp&lt;/a&gt;前端部分快完成了。来整理一下&lt;a href=&quot;https://www.freecodecamp.cn/&quot; target=&quot;_blank&quot;&gt;freeCodeCamp&lt;/a&gt;的算法题。这些题都相对简单，用来熟悉API的使用。这篇文章选了部分初级算法题进行整理。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://www.yinfengblog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基于Github Pages+Hexo的个人博客</title>
    <link href="http://www.yinfengblog.com/%E5%9F%BA%E4%BA%8EGithub%20Pages+Hexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.yinfengblog.com/基于Github Pages+Hexo的个人博客/</id>
    <published>2017-01-11T05:45:16.000Z</published>
    <updated>2017-01-23T05:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了一天，搭建了一个简陋的博客，用来记录自己在学习前端过程中的思考总结。<br><a id="more"></a><br>  博客会记录自己对一些前端重要知识的思考，在FCC练习的总结和自己平时练手的项目。像我这种懒人就不会在博客美化UI和丰富功能上花太多精力了<em>(:з)∠)</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;折腾了一天，搭建了一个简陋的博客，用来记录自己在学习前端过程中的思考总结。&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="http://www.yinfengblog.com/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.yinfengblog.com/hello-world/"/>
    <id>http://www.yinfengblog.com/hello-world/</id>
    <published>2017-01-10T14:15:40.000Z</published>
    <updated>2017-01-26T06:58:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post.<br><a id="more"></a><br>Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post.&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="http://www.yinfengblog.com/categories/blog/"/>
    
    
  </entry>
  
</feed>
